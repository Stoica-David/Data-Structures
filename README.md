# Data Structures

This is my homework for data structures in the second semester of my first year of college. Below is an explanation for each file attached.

Anagrams.cpp - given an array of words, write a function that groups all the words into groups of anagrams (two words are anagrams if you can obtain one of them by rearranging the letters of the other one);

BinarySearchTree.cpp - implementation of a binary search tree;

BinaryTree.cpp - implementation of a binary tree;

BSequence.cpp - a B-Sequence is an array with the following properties: the array is ascending until a certain number, from where it is decreasing. Each element, excepting the maximum element can appear two times at most, once in the ascending side and once in the decreasing side and each element in the decreasing side can be found in the ascending side. Given a B-Sequence and k values, for each value check if you can insert it in the sequence;

BucketSort.cpp - the bucketsort algorithm using linked lists;

Competitors.cpp - there are n competitions and each one has its own number of competitors, show the competitors that joined at least two competitions;

Dices.cpp - 3 dices are thrown N times, for each throw there are three random generated numbers from one to six, for each tuple from the given input, show how many times it has been thrown (permutations of a tuple are considered the same tuple);

Dictionary.cpp - given a string, show the words in it in alphabetic order and for each word show how many times it appears in the string;

Duplicates.cpp - given a vector of numbers and a value distance, show all the duplicates between which there are at most a number of distance elements;

HashTable.h + HashTable.cpp + HashTableMain.cpp - the implementation of a hashtable using linked lists;

HeapSort.cpp - the heapsort algorithm;

LinkedList.cpp - implementation of a linked list;

MergeNVectors.cpp - the merge algorithm using a priority queue (for a number of n vectors);

OrderStatisticTree.cpp - implementation of a order statistic tree using my implementation of a red-black tree;

Permutations.cpp - given two strings, check if the second one is a permutation of the first one;

Pharantesis.cpp - given an array of pharantesis check if the pharantesis are opened and closed correctly;

PolishNotation.cpp - given a number of n arithmetic expressions, form and print the postfix polish notation;

PolishTree.cpp - form a tree with the polish notation of each given arithmetic expression;

PriorityQueue.cpp - implementation of a priority queue;

Queue.cpp - implementation of a queue using a linked list;

RedBlackTree.cpp - implementation of a red-black tree;

Shops.cpp - there are n shops, each contains its own number of products. Check which shop has the most exclusive products (by exclusive we understand a product that can only be found in one shop);

Squares.cpp - there are n squares, for each square we know the coordinates of its center and the size of its side. Given the coordinates of a point, check if there is a square that is centered in the given point, if there are more squares print the square of maximum/minimum size;

Stack.cpp - implementation of a stack using two queues, also it contains a solution for the pharantesis problem that I solved in the pharantesis.cpp file;

WaitingList.cpp - create a waiting list using a map from STL, then print the first three candidates then check if there is a candidate with the name Ionescu on the list;

ZeroSum.cpp - there are 4 vectors of integers, print all the possible sums that equal to zero and contain exactly one number from each vector. 

